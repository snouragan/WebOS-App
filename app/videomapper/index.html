<!DOCTYPE html>
<html>

<head>
	<title>Video Mapper</title>
	<style type="text/css">
		html {
			height: 100vh;

			display: flex;
			display: -webkit-flex;
		}

		body {
			display: flex;
			display: -webkit-flex;

			align-items: center;
			-webkit-align-items: center;

			justify-content: center;
			-webkit-justify-content: center;
		}

		div.bg {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			height: auto;
			width: auto;
			background: rgb(255, 255, 255);
		}

		div.container {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			height: auto;
			width: auto;

			transform-origin: center;
			-webkit-transform-origin: center;

			display: flex;
			display: -webkit-flex;

			flex-direction: column;
			-webkit-flex-direction: column;

			align-items: center;
			-webkit-align-items: center;

			justify-content: start;
			-webkit-justify-content: start;
		}

		video#video {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			height: auto;
			width: auto;
		}
	</style>

	<script src="webOSTVjs-1.2.4/webOSTV.js" charset="utf-8"></script>
	<script src="webOSTVjs-1.2.4/webOSTV-dev.js" charset="utf-8"></script>
	<script src="config.js"></script>
</head>

<body>
	<div class="bg">
	</div>
	<div class="container">
		<video muted id="video"></video>
	</div>

	<script type="text/javascript">

		const videoElement = document.getElementById("video");

		let videoFile = undefined;

		let initialized = false;

		let timeout = 0;

		// Fetch video file and save as blob:
		fetch('http://' + SERVER_IP + '/sdata/untitled.webm', {
			method: 'GET'
		}).then(res => res.blob()).then(blob => {
			videoFile = blob;
			display(videoFile, videoElement);
			if (LOGGING) {
				console.log('loaded video');
			}
			timeout = INIT_TIMEOUT;
		});

		// Start init cooldown after receiving video file:
		const initInterval = setInterval(() => {

			// Clear interval once initialized:
			if (initialized) {
				clearInterval(initInterval)
			}

			// If video file is loaded, start countdown:
			if (timeout !== 0) {
				if (LOGGING) {
					console.log(timeout);
				}
				timeout--;

				// Request sync from server when countdown reaches zero:
				if (timeout === 0) {
					fetch('http://' + SERVER_IP + '/sync', {
						method: 'GET'
					}).then(res => {
						initialized = true;
						videoElement.play();
					});
				}
			}
		}, 1000);

		// Ask for server sync when playback ends:
		videoElement.addEventListener('ended', () => {
			fetch('http://' + SERVER_IP + '/sync', {
				method: 'GET'
			}).then(res => {
				videoElement.currentTime = 0;
				videoElement.play();
			});
		});


		
		// source: https://stackoverflow.com/questions/14317179/display-a-video-from-a-blob-javascript
		function display(videoFile, videoEl) {

			// Preconditions:
			if (!(videoFile instanceof Blob)) throw new Error('`videoFile` must be a Blob or File object.'); // The `File` prototype extends the `Blob` prototype, so `instanceof Blob` works for both.
			if (!(videoEl instanceof HTMLVideoElement)) throw new Error('`videoEl` must be a <video> element.');

			// 

			const newObjectUrl = URL.createObjectURL(videoFile);

			// URLs created by `URL.createObjectURL` always use the `blob:` URI scheme: https://w3c.github.io/FileAPI/#dfn-createObjectURL
			const oldObjectUrl = videoEl.currentSrc;
			if (oldObjectUrl && oldObjectUrl.startsWith('blob:')) {
				// It is very important to revoke the previous ObjectURL to prevent memory leaks. Un-set the `src` first.
				// See https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL

				videoEl.src = ''; // <-- Un-set the src property *before* revoking the object URL.
				URL.revokeObjectURL(oldObjectUrl);
			}

			// Then set the new URL:
			videoEl.src = newObjectUrl;

			// And load it:
			videoEl.load(); // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/load
		}
	</script>

</body>

</html>